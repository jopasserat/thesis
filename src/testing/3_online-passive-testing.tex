\subsection{Online passive testing}
\label{sec:testing:online}

Our online passive testing algorithm, which aims to check whether
the two previous implementation relations hold, is given in
Algorithm \ref{algo:check-online}. It also takes the same models
$R(\EuScript{S}^{N})$ and $D(\EuScript{S}^{N})$, with regards to
Propositions \ref{rel:impl12} and \ref{rel:impl2}, and it returns
the same verdicts "Pass$\leq_{ct}$" or "Pass$\leq_{mct}$" if the
relations $\leq_{ct}$ or $\leq_{mct}$ are satisfied.

In online mode, we don't have complete traces (like
$CTraces({Sut})$), but traces that are constructed on-the-fly by
an instance of tester, everytime an event is received. Each event
is filtered and transformed into a filtered valued event, from
which we extract its product identifier $pid$. The valued event
is then forwarded to the right tester, i.e. the instance for this
$pid$. If there is no instance yet, we create a new tester for
this $pid$ first, and then we forward the valued event. There
should be one instance of tester running the same Algorithm
\ref{algo-check-online} per $pid$, i.e. per product being
manufactured.

\TODO{tester constructs a trace, then tries to check it over R or D
    it stops (and trace is possibly failed) when check has failed}


\begin{algorithm}[h]
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \SetKwFunction{check}{check}

    \Input{$R(\EuScript{S}^{N})=\{R(\EuScript{S}_1^{N}),...,R(\EuScript{S}_n^{N})\},
    D(\EuScript{S}^{N})=\{D(\EuScript{S}_1^{N}),...,D(\EuScript{S}_n^{N})\}, CTraces({Sut})$}
    \Output{Verdicts or possibly fail trace sets $T_1, T_2$ }

    BEGIN\;
    $trace = \emptyset$\;

    \While{..}{
        $trace = $
    }

    END\;

    \caption{Online passive testing algorithm}
    \label{algo:check-online}
\end{algorithm}
