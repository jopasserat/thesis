% !TEX root = ../../thesis.tex
%
\chapter{Introduction}
\label{sec:intro}

\minitoc

I am studying Computer Science for more than 8 years now. I
remember my first lectures on quality assurance (QA) and software
testing, how pointless it seemed to all of us, students who don't
write bugs \footnote{The last part of this sentence is adapted
from this tweet:
\url{https://twitter.com/hipsterhacker/status/396352411754717184}.}.
Indeed, almost a decade ago, quality assurance was not a common
practice, and researchers had to prove what the benefits of, for
instance, testing could be. Generally speaking, quality assurance
is a way of preventing faults in manufactured products, which is
defined in ISO 9000 as "part of quality management focused on
providing confidence that quality requirements will be fulfilled"
\cite{iso20059000}. Software testing provides information about
the quality of software. For instance, testing can prove
confidence of a software system by executing a program with the
intent of finding errors, also known as "bugs"
\cite{Myers:1979:AST:539883}.

Nowadays, quality assurance and software testing are well-known
in the Industry, and everyone understands the need for them.
However, testing is often performed by hand, which is complicated
and far from perfect. Software testing can be seen as a sequence
of three major steps:

\begin{enumerate}
    \item The design of test cases that are good at revealing
        faults, according to a certain level of requirement;

    \item The execution of these test cases;

    \item The determination of whether the output produced is
        correct.
\end{enumerate}

Sadly, the test case execution is often the only fully automated
aspect of this activity in the Industry. Continuous Integration
(CI) \cite{booch1991object} is now associated with the automation
of the execution of test cases and quick feedback, often received
by email. There are countless tools and services
\footnote{For example, Travis CI: https://travis-ci.org/.} to
automate this process, but too few tools have emerged to tackle
the problem of test case generation for instance. Fortunately, in
Academia, researchers have studied such a problem for decades
\cite{4221614}.

A relatively recent field to automate and improve testing is
Model-based Testing (MbT). While the original idea has been
around for decades \cite{moore56}, there has been a growing
interest over the last few years.  MbT is application of (formal)
Model-based design for designing and optionally also executing
artifacts to perform software testing
\cite{Jorgensen:1995:STC:526521}. To make a long story short, the
use of a model allows to formally describe the expected behaviors
of a software, from which it is possible to automatically
generate the test cases, and then to execute them.  Nonetheless,
writing such models is tedious and error-prone, which is a
drawback and can also explain the slow adoption of MbT in the
Industry.

Model inference is a research field that aims at automatically
deriving models, expressing functional behaviors of existing
software for example. These models, even if incomplete, help
understand how a software behaves. That is why model inference is
interesting to solve the limitation of MbT mentioned previously.
Most of the model inference techniques that are used for testing
purpose are not designed to infer large models or to test large
software systems though. Anti-Model-based Testing \cite{antimbt} is
somehow related to this idea, although Anti-Model-based Testing
is more about using testing to reverse-engineer a model, and then
check such a model to detect whether the software behaves
correctly. In this thesis, reverse-engineering of a model is
achieved by monitoring the system without disturbing it or even
stimulating it, i.e. we don't rely on testing during model
inference.

Michelin, one of the three largest tire manufacturers in the
world, has been our industrial partner for the last three years.
The company designs most of its factories, production machines,
and software itself. In a factory, there are several workshops
for the different parts of the manufacturing process. From our
point of view, a workshop is seen as a set of production machines
controlled by a software. That is what we call a production
system. Such systems deal with many physical devices, databases,
and also human interactions. Most of these systems run for years,
up to 20 years. Maintaining and updating such legacy software is
complicated as documentation is often outdated, and the
developers who wrote these software are not available anymore.
In this thesis, we propose a solution to the problem of testing
such systems: \textit{Autofunk}, a framework combining different
techniques to: (i) infer formal models from large (legacy)
software systems, and (ii) perform passive testing in order to
detect potential regressions.

\TODO{section on which problems this thesis adresses?}

The next presents the contributions of this thesis. Section
\ref{sec:intro:overview} gives the overview of this thesis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Contributions}
\label{sec:intro:contrib}

The contributions of this thesis are:

\begin{enumerate}
    \item \textit{Autofunk}, a framework, combining several
        techniques originating from different fields such as
        expert systems, machine learning and model inference, for
        inferring formal models of legacy software systems.
        Autofunk's modular architecture allows multiple
        extensions;

    \item An empirical study that evaluates Autofunk on web
        applications for inferring models. Here, Autofunk is
        combined with an automatic testing technique to interact
        with web applications in order to improve the
        completeness of the inferred models. Several models can
        be built at different levels of abstraction, allowing to
        create, for instance, human-readable documentation;

    \item An empirical study that evaluates Autofunk on
        Michelin's production systems, proving that it is able to
        build exact models in an efficient manner, based on large
        sets of traces (for now, we can define a set of traces as
        information collected from a software system, and
        describing its behaviors);

    \item A reduction technique for symbolic transition systems
        that is both fast and efficient, keeping the exactness of
        the models, and targetting large models;

    \item An offline passive testing technique leveraging the
        inferred models for testing production systems, along
        with a case study. This work is an extension of Autofunk;

    \item An online passive testing technique similar to the
        offline passive testing, but enabling on the fly testing
        of production systems.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}
\label{sec:intro:overview}

\textbf{Chapter \ref{sec:related}} surveys the literature in
software testing first, and then in model inference applied to
software systems. The chapter starts by introducing what software
testing means, mentioning some important notions as well as the
different types of testing. It then presents what Model-based
Testing (MbT) is, along with a few definitions and common terms
employed in MbT. The software testing part ends with a review on
some passive testing techniques, and why they are interesting in
our case. The second part of this chapter presents what model
inference is, from active learning to passive learning
techniques.

\textbf{Chapter \ref{sec:modelinf:webapps}} presents our work on
model inference applied to web applications, a preliminary work
that gave birth to \textit{Autofunk}, our modular framework for
inferring models (and later, performing testing). This chapter
gives an overview of Autofunk's very first architecture. It then
presents how Autofunk relies on an automatic testing technique to
improve the completeness of the inferred models. A note on its
implementation is then given, following by an experimentation.


\textbf{Chapter \ref{sec:modelinf:prodsystems}} introduces our
framework Autofunk revisited to target production systems. This
chapter gives the context that led to our choices regarding the
edesign of Autofunk. Our reduction technique that heavily reduces
models is then presented, along with the results of a case study
on Michelin's production systems. A whole section is dedicated to
the implementation of Autofunk for Michelin. Last significant
part of this chapter is the use of a machine learning technique
to maximize one part of our model inference technique.

\textbf{Chapter \ref{sec:testing}} tackles the problem of testing
production systems, without disturbing them, and without having
any specification. It presents our work on both offline and
online passive testing, by extending Autofunk's model inference
ramework. After having presented the overall idea, two algorithms
are given and explained. The results of a case study on
Michelin's production systems is given. Such results are related
to the offline passive testing technique.

\textbf{Chapter \ref{sec:conclusion}} closes the main body of the
thesis with concluding comments and proposals for future work.

% The End.
\cleardoublepage
\blankpage
