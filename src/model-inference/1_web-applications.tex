\chapter{Model inference for web applications}
\label{sec:modelinf:webapps}

Models are essential while working on the design of complex
systems to build reliable implementations. But, they are also
particularly useful when systems reach maintenance cycle, easing
comprehension of the overall design and describing how these
systems work under the hood. This is important because people who
are responsible for maintaining or improving systems are most
likely not the same who designed and built them. It is nearly
impossible for one person to know all the details related to a
particular system, hence the need for creating and maintaining
models.

Before tackling the model inference of production systems, we
chose to validate our first ideas and concepts by applying them
on web applications.

\TODO{Add more stuff on web apps}

We proposed a new approach to infer models of web applications.
Such an approach is divided into several modules as depicted in
Figure \ref{fig:framework}. The \emph{Models generator} is the
centrepiece of this framework. It takes traces as inputs, which
can be sent by a \emph{Monitor} collecting them on the fly. But
it is worth mentioning that the traces can also be sent by any
tool or even any user, as far as they comply to a chosen standard
format. The Models generator is based upon an expert system,
which is an artificial intelligence engine emulating acts of a
human expert by inferring a set of rules representing his
knowledge. Such knowledge is organised into a hierarchy of
several layers. Each one gathers a set of inference rules written
with a first order logic. Typically, each layer creates an IOSTS,
and the higher the layer is, the more abstract the IOSTS becomes.
Models are then stored and can be later analysed by experts,
verification tools, etc. The number of layers is not strictly
bounded even though it is manifest that it has to be finite.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[width=1.0\linewidth]{figures/soict-framework.png}
    \end{center}

    \caption{Model generation framework}
    \label{fig:framework}
\end{figure}

The Models generator relies upon traces to construct IOSTSs, but
the given trace set may not be substantial enough to generate
relevant IOSTSs. More traces could be yet collected as far as
the application being analysed is an event-driven application.
Such traces can be produced by stimulating and exploring the
application with automatic testing. In our approach, this
exploration is achieved by the \emph{Robot explorer}. In contrast
with most of the existing crawling techniques
\cite{Memon:2003,concolicandroid12,crawljax:tweb12,Amalfitano:2012:UGR:2351676.2351717,WPX13},
our robot does not cover the application in blind mode or with a
static traversal strategy. Instead, it is cleverly guided by the
Models generator which applies an exploration strategy carried
out by rules. This involves the capture of new traces by the
Monitor or by the Robot explorer which returns them to the Models
generator. The advantages of this approach are manifold:

\begin{itemize}
\item it takes a predefined set of traces collected from any kind
of applications producing traces. In the context of Web
applications, traces can be produced using automatic testing,

\item the application exploration is guided with a strategy which
can be modified according to the type of application being
analysed. This strategy offers the advantage of directly targeting
some states of the application when its state number is too large
for being traversed in a reasonable processing time,

\item the knowledge encapsulated in the expert system can be used
to cover trace sets of several applications belonging to the same
category with generic rules,

\item but, the rules can also be specialised and refined for one
application to yield more precise models. This is interesting for
application comprehension,

\item our approach is both flexible and scalable. It does not
produce one model but several ones, depending on the number of
layers of the Models generator, which is not limited and may
evolve in accordance to the application's type. Each model,
expressing the application's behaviours at a different level of
abstraction, can be used to ease the writing of complete formal
models, to apply verification techniques, to check the
satisfiability of properties, to automatically generate
functional test cases, etc.
\end{itemize}

We describe our work in the next section, then we present our
results in Section \ref{sec:modelinf:webapps:exp}, and we
conclude on this work in Section
\ref{sec:modelinf:webapps:conclusion}. This work has been
published in \cite{DBLP:conf/soict/DurandS14}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Contribution}
\label{sec:modelinf:webapps:contrib}

\begin{figure}[ht]
    \begin{center}
        \includegraphics[width=1.0\linewidth]{figures/se.png}
    \end{center}
    \caption {Models generator}
    \label{fig:se}
\end{figure}

The Models generator is mainly composed of a rule-based expert
system, adopting a forward chaining. Such a system separates the
knowledge base from the reasoning: the former is expressed with
data a.k.a. facts and the latter is realised with inference rules
that are applied on the facts. Our Models generator initially
takes traces as an initial knowledge base and owns inference
rules organised into layers for trying to fit the human expert
behaviour. These layers are depicted in Figure \ref{fig:se}.

Usually, when a human expert has to read traces of an
application, he often filters them out to only keep those which
make sense against the current application. This step is done by
the first layer whose role is to format the received raw traces
into sequences of valued actions and to delete those considered
as unnecessary. The implementation of this layer depends on the
nature of the input traces. The resulting structured trace set,
denoted $ST$, is then given to the next layer. This process is
incrementally done, i.e. every time new traces are given to the
Models generator, these are formatted and filtered before being
given to Layer 2. The remaining layers yield an IOSTS each
$\EuScript{S}_i (i\geq 1)$, which has a tree structure derived
from the traces. The role of Layer 2 is to carry out a first
IOSTS transformation from the structured traces. The next layers
3 to N (with N a finite integer) are composed of rules that
emulate the ability of a human expert to simplify transitions, to
analyse the transition syntax for deducing its meaning in
connection with the application, and to construct more abstract
actions that aggregate a set of initial ones. Theses deductions
are often not done in one step. This is why the Models generator
supports a finite but not defined number of layers.  Each of
these layers $i$ takes the IOSTS $\EuScript{S}_{i-1}$ given by
the direct lower layer. This IOSTS, which represents the current
base of facts, is analysed by the rules to infer another IOSTS
whose expressiveness is more abstract than the previous one. We
state that the lowest layers (at least Layer 3) should be
composed of generic rules that can be reused on several
applications of the same type. In contrast, the highest layers
should own the most precise rules that may be dedicated to one
specific application.

For readability purpose, we chose to represent inference rules
with this format: \emph{When conditions on facts Then actions on
facts} (format taken by the Drools inference engine
\footnote{http://www.jboss.org/drools/}). Independently on the
application's type, Layers 2 to N handle the following fact
types: \emph{Location} which represents an IOSTS location, and
\emph{Transition}, which represents an IOSTS transition, composed
of two Locations Linit, Lfinal, and two data collections Guard
and Assign. Now, it is manifest that the inference of models has
to be done in a finite time and in a deterministic way. To reach
that purpose, we formulate the following hypotheses on the
inference rules:

\begin{enumerate}
\item (finite complexity): a rule can only be applied a limited number of times on the same knowledge base,
\item (soundness): the inference rules are Modus Ponens (simple
implications that lead to sound facts if the original facts are
true: If P, then Q. P. Therefore, Q.),
\item (no implicit knowledge elimination): after the application of a rule $r$ expressed by the relation $r: T_i \rightarrow
T_{i+1} (i\geq 2)$, with $T_i$ a Transition base, for all transition $t=(l_n,l_m,a(p),G,A)$ extracted from
$T_{i+1}$, $l_n$ is reachable from $l_0$.
\end{enumerate}

In the following, we detail these layers in the context of Web
applications while giving some rule examples.

\subsection{Layer 1: Trace filtering}
\label{sec:modelinf:webapps:L1}

Traces of Web applications are based upon the HTTP protocol,
conceived in such a way that each HTTP request is followed by
only one HTTP response. Consequently, the traces, given to Layer
1, are sequences of couples (HTTP request, HTTP response). This
layer begins formatting these couples so that these can be
analysed in a more convenient way.

\begin{comment}
In short, an HTTP request is a textual message containing an HTTP
verb, followed by a Unique Resource Identifier (URI). It may also
contain header sections such as Host, Connection, or Accept. The
corresponding HTTP response is also a textual message containing
at least a status code. It may encompass headers (e.g,.
Content-Type, Content-Length) and a content. All these notions
can be easily identified.
\end{comment}

\begin{comment}
For instance, Figure \ref{httpexample} lists an HTTP request
followed by its response. This is a $GET$ HTTP request, meaning a
client wants to read the content of the $/hello$ resource, which
is, in this case, a web page in HTML.

\begin{figure}[ht]
\begin{center}
\begin{verbatim}
GET /hello HTTP/1.1
Host: example.org
Connection: keep-alive
Accept: text/html
\end{verbatim}

\begin{verbatim}
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 13
Hello, World!
\end{verbatim}
\end{center}
\caption{HTTP request / response example}
\label{httpexample}
\end{figure}
\end{comment}

For a couple  (HTTP request, HTTP response), we extract the
following information: the HTTP verb, the target URI, the request
content which is a collection of data (headers, content) and the
response content which is the collection (HTTP status, headers,
response content). A header may also be a collection of data or
may be null. Contents are texts e.g., HTML texts. Since we wish
translating such traces into IOSTSs, we turn these textual items
into a structured valued action $(a(p),\theta)$ with $a$ the HTTP
verb and $\theta$ a valuation over the variable set
$p=\{URI,request,response\}$. This is captured by the following
proposition:

\begin{definition}[Structured HTTP Traces] Let $t=
req_1,resp_1$, ..., $req_n,$ $resp_n$ be a raw HTTP trace
composed of an alternate sequence of HTTP request $req_i$ and
HTTP response $resp_i$. The structured HTTP trace $\sigma$ of $t$
is the sequence $(a_1(p),\theta_1)...(a_n(p),\theta_n)$ where:
\begin{itemize} \item $a_i$ is the HTTP verb used to make the
request in $req_i$, \item $p$ is the parameter set $\{URI,
request, response\}$, \item $\theta_i$ is a valuation $p
\rightarrow D_p$ which assigns a value to each variables of $p$.
$\theta$ is deduced from the values extracted from $req_i$ and
$resp_i$.

\end{itemize}
The resulting trace set derived from raw HTTP traces is denoted
$ST$.
\end{definition}

\begin{comment}
If we take back the HTTP messages of Figure \ref{httpexample}, we
obtain the structured trace $(Get(p), \theta)$ with $\theta$
composed of {URI="/hello", request={headers=[ Host=
"example.org", Connection = "keep-alive", Accept = "text/html"
]}, response={statusCode=200, headers=[ Content-Type =
"text/html", Content-Length = 13], content= "Hello, World!"} }.
\end{comment}

Now, structured traces can be filtered. For a main request
performed by a user, many other sub-requests are also launched by
a browser in order to fetch images, CSS and JavaScript files.
Generally speaking, these do not enlighten a peculiar functional
behaviour of the application. This is why we propose to add rules
in Layer 1 to filter these sub-requests out from the traces. Such
sub-requests can be identified by different ways, e.g., by
focussing on the file extension found at the end of the URI, or
on the Content-type value of the request headers. Consequently,
we created a set of rules, constituted of conditions on the HTTP
content found in an action, that remove valued actions when the
condition is met. A straightforward rule example, which removes
the actions relative to the retrieval of PNG images, is given in
Figure \ref{fig:layer1:filter}.

\begin{comment}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "Filter"
when
    $t: HttpVerb(condition on the  content)
then
    retract($t);
end
\end{verbatim}
\end{scriptsize}
\end{comment}

\begin{figure}[ht]
    \begin{center}
    \begin{verbatim}
    rule "Filter PNG images"
    when
        \$va: Get(request.mime_type = 'png' or
        request.file_extension = 'png')
    then
        retract(\$va);
    end
    \end{verbatim}
    \end{center}

    \caption{Filtering rule example}
    \label{fig:layer1:filter}
\end{figure}

After the instantiation of the Layer 1 rules, we obtain a
formatted and filtered trace set $ST$ composed of valued actions.
Now, we are ready to extract the first IOSTS.

\textit{Completeness, soundness, and complexity.} HTTP traces are
sequences of valued actions modelled with positive facts.
Typically, they form Horn clauses. Furthermore, inference rules
are Modus Ponens (soundness hypothesis). Consequently, Layer 1 is
sound and complete. Keeping in mind the finite complexity
hypothesis, its complexity is proportional to
$\EuScript{O}m(k+1)$ with $m$ the valued action number and $k$
the rule number. (at worst, every action is covered $k+1$ times).

\subsection{Layer 2: IOSTS transformation}
\label{sec:modelinf:webapps:L2}

Intuitively, the IOSTS transformation relies upon the IOLTS
semantics transformation that is achieved in a backward manner.
In order to generate the first IOSTS denoted $\EuScript{S}_1$,
the associated runs are first computed from the structured traces
by injecting states between valued actions.

These steps are detailed below:

\paragraph{Traces to runs}

Given a trace $\sigma$, a run $r$ is firstly derived  by
constructing and injecting states on the right and left sides of
each valued action of $\sigma$. Keeping in mind the IOLTS
semantics definition, a state shall be modelled by the couple
$((URI,k),v_\emptyset)$ with $v_\emptyset$ the empty valuation.
$(URI,k)$ is a couple composed of a URI and of an integer $(k
\geq 0)$. Typically, a couple $(URI,k)$ shall be a location of
the future IOSTS. All the runs $r$ of $SR$ start with the same
state $(l0,v_\emptyset)$. Then, a run is constructed by
incrementally covering one trace: for an action actions
$(a_i,\theta_i)$ found in a trace, we extract the valuation
$URI=val$ from $\theta_i$ giving the URI value of the next
resource reached after the action $a_i$.And we complete the
current run $r$ with $(a_i,\theta_i)$ followed by the state
$((val,k),v_\emptyset)$. Since we wish to preserve the sequential
order of the actions found in the traces, when a URI previously
encountered is once more detected, the resulting state is
composed of the URI accompanied with an integer $k$, which is
incremented to yield a new and unique state. Due to lack of room,
the algorithm translating the structured traces into a run set is
not provided in this paper but can be found in \cite{RR14}.

The translation of the structured traces into a run set is
performed by Algorithm \ref{traces_to_runs} which takes the trace
set $ST$ and returns the run set $SR$. It handles a set $States$
storing the constructed states. All the runs $r$ of $SR$ start
with the same state $(l0,v_\emptyset)$. Algorithm
\ref{traces_to_runs} covers the actions $(a_i,\theta_i)$ of a
trace $\sigma$ in order to construct the next state $s$. It
extracts the valuation $URI=val$ (line 7) from $\theta_i$ giving
the URI value of the next resource reached after the action
$a_i$. The state $s=((val,k+1),v_\emptyset)$ is constructed with
$k$ such that there exists $((URI,k),v_\emptyset) \in States$
composed of the greatest integer $k \geq 0$. The current run $r$
is completed with the valued action $(a_i,\theta_i)$ followed by
the state $s$ (line 13). Finally, $SR$ gathers all the
constructed runs.

\begin{algorithm}
\SetKwInOut{Input}{input} \SetKwInOut{Output}{output}

\Input{Trace set $ST$}
\Output{Run set $SR$}

BEGIN\;

$States:=\emptyset$ is the set of the constructed states\;

\If{$ST$ is empty} {
$SR:= \{(l0,v_\emptyset)\}$}

\ForEach{trace $\sigma=(a_0,\theta_0)...(a_n,\theta_n) \in ST$} {
$r:= (l0,v_\emptyset)$\;

\For{ $0 \leq i \leq n$}{

extract the valuation $URI=val$ from $\theta_i$\;

\If{($(val,0),v_\emptyset) \notin States$}{
$s:=((val,0),v_\emptyset)$\; }

\Else{ $s:=((val,k+1),v_\emptyset)$ with $k\geq 0$ the greatest
integer such that $((val,k),v_\emptyset) \in States$\; }

$States:=States \cup \{s\}$\;

$r:=r.(a_i,\theta_i).s$

}%endfor_i

$SR:=SR \cup \{r\}$

}%endfor trace

END\;

    \caption{Traces to Runs algorithm}
    \label{traces_to_runs}
\end{algorithm}

\TODO{review algorithm}

\begin{proposition}
Foe each trace $\sigma \in ST$, Algorithm \ref{traces_to_runs}
constructs a run $r=s_0(a_0,\theta_0)s_1 \dots\\s_n(a_n,\theta_n)s_{n+1} \in SR$ such that $\forall (a_i,\theta_i)
( 0<i\leq n), \exists ! s_i(a_i,\theta_i)s_{i+1}$ in $r$.
\end{proposition}

\paragraph{IOSTS generation}
\label{sec:iosts-gen}

The first IOSTS $\EuScript{S}_1$ is derived from the run set $SR$
in which runs are disjoint except for the initial state
$(l0,v_\emptyset)$. Intuitively, traces are translated into IOSTS
paths that are assembled together (IOSTS disjoint union). The
IOSTS forms a tree composed of paths, each expressing one trace,
starting from the same initial location.

\begin{definition}%State(Runs)
\label{IOSTS_tree}

Given a run set $SR$, the IOSTS $\EuScript{S}_1$ is called the
IOSTS tree of $SR$ and corresponds to the tuple
$<L_{\EuScript{S}_1}, l0_{\EuScript{S}_1},V_{\EuScript{S}_1},
V0_{\EuScript{S}_1}, I_{\EuScript{S}_1},
\Lambda_{\EuScript{S}_1},\rightarrow_{\EuScript{S}_1}>$ such
that:
\begin{itemize}

\item $L_{\EuScript{S}_1}= \{l_i \mid \exists r\in SR, (li,v_\emptyset)$ is
a state found in $r\}$,

\item $l0_{\EuScript{S}_1}$ is the initial location such that $\forall r \in
SR$, $r$ starts with $(l0_{\EuScript{S}_1},v_\emptyset)$,

\item $V_{\EuScript{S}_1}=\emptyset$, $V0_{\EuScript{S}_1}=v_\emptyset$,

\item $\Lambda_{\EuScript{S}_1}= \{a_i(p) \mid \exists r\in SR,
(a_i(p),\theta_i)$ is a valued action in $r\}$,

\item $\rightarrow_{\EuScript{S}_1}$ is defined by the following inference
rule applied on every element $r\in SR$:
\end{itemize}
\noindent\fbox{%
\begin{minipage}{0.98\textwidth}
\begin{center}
\begin{tabular}{l}
$s_i (a_i(p),\theta_i) s_{i+1} \text{ is a term
of } r, s_i=(l_i,v_\emptyset),$\\
$s_{i+1}=(l_{i+1},v_\emptyset), G_i=\displaystyle \bigwedge_{(x_i=vi)\in \theta_i} x_i==vi$\\
$\vdash$
$l_i \xrightarrow{a_i(p),G_i,(x:=x)_{x\in V}}_{\EuScript{S}_1} l_{i+1}$\\
\end{tabular}

\end{center}
\end{minipage}%
}
\end{definition}

Here, locations could be merged to reduce the IOSTS size with the
classical learning algorithms based upon $\EuScript{L}^*$
\cite{Angluin198787,lambeau08}. Nonetheless, these
would create an extrapolation of this IOSTS. We prefer rejecting
such a solution to preserve the trace equivalence of the IOSTS
$\EuScript{S}_1$ against the structured trace set $ST$ before
applying inference rules. Instead, we propose to use a
minimisation technique.

\paragraph{IOSTS minimisation}

This IOSTS tree can be reduced in term of location size by
applying a bisimulation minimisation technique which still
preserves the functional behaviours expressed in the original
model.  Intuitively, this minimisation constructs the state sets
(blocks) that are bisimilar equivalent. Two states are said
bisimilar equivalent, denoted $q \sim q'$ iff they simulate each
other and go to states from where they can simulate each other
again. Due to lack of room, we only refer to the bisimulation
minimisation algorithm of \cite{Fernandez89animplementation}.

When receiving new traces from the Monitor, the model yield by
this layer is not fully regenerated, but rather completed on the
fly. New traces are translated into IOSTS paths that are disjoint
from $\EuScript{S}_1$ except from the initial location. We
perform an union between $\EuScript{S}_1$ and IOSTS paths. Then,
the resulting IOSTS is minimised.

\textit{Completeness, soundness, complexity.} Layer 2 takes any
structured trace set obtained from HTTP traces. If the trace set
is empty then the resulting IOSTS $\EuScript{S}_1$ has a single
location $l_0$. A structured trace set is translated into an
IOSTS in finite time: every valued action of a trace is covered
once to construct states, then every run is lifted to the level
of one IOSTS path starting from the initial location. Afterwards,
the IOSTS is minimised with the algorithm presented in
\cite{Fernandez89animplementation}. Its complexity is
proportional to $\EuScript{O}(mlog (m+1))$ with $m$ the number of
valued actions. The soundness of Layer 2 is based upon the notion
of traces: an IOSTS $\EuScript{S}_1$ is composed of transition
sequences derived from runs in $SR$, itself obtained from the
structured trace set $ST$. As defined, the behaviours encoded in
$ST$ and $\EuScript{S}_1$ are equivalent since ordered runs are
transformed into ordered IOSTS sequences.

For sake of readability, we do not provide here the rules of
Layer 2, which match the above definitions and algorithms.
Instead, we illustrate an IOSTS generation example below:

\begin{example}
We take as example a trace obtained from the GitHub website
\footnote{https://github.com/} after having executed the
following actions: login with an existing account, choose an
existing project, and logout. These few actions already produced
a large set of requests and responses. Indeed, a web browser
sends thirty HTTP requests on average in order to display a
GitHub page. The trace filtering from this example returns the
following structured traces where the request and response parts
are concealed for readability purpose:

\begin{lstlisting}
GET(https://github.com/)
GET(https://github.com/login)
POST(https://github.com/session)
GET(https://github.com/)
GET(https://github.com/willdurand)
GET(https://github.com/willdurand/Geocoder)
POST(https://github.com/logout)
GET(https://github.com/)
\end{lstlisting}

After the application of Layer 2, we obtain the IOSTS of Figure
\ref{fig:github:iosts:1}. Locations are labelled by the URI found
in the request and by an integer to keep the tree structure of
the initial traces. Actions are composed of the HTTP verb enriched
with the variables URI, request, and response. This IOSTS exactly
reflects the trace behaviour but is still difficult to interpret.
More abstract actions shall be deduced by the next layers.
\end{example}

\begin{figure}[ht]
    \begin{center}
        \includegraphics[width=1.0\linewidth]{figures/gh-iosts-1.png}
    \end{center}
    \caption{IOSTS $\EuScript{S}_1$}
    \label{fig:github:iosts:1}
\end{figure}

\subsection{Layers 3-N: IOSTS abstraction}
\label{sec:modelinf:webapps:L4}

As stated earlier, the rules of the upper layers analyse the
transitions of the current IOSTS for trying to enrich its
semantics while reducing its size. Given an IOSTS
$\EuScript{S}_1$, every next layer carries out the following
steps:\\
1. apply the rules of the layer and infer a new knowledge base
(new IOSTS $\EuScript{S}_i$, $i\geq 2$),\\
2. apply a bisimulation minimisation,\\
3. store the resulting IOSTS.

Without loss of generality, we now restrict the rule structure to
keep a link between the generated IOSTSs. Thereby, every rule of
Layer $i$ ($i \geq 3$) either enriches the sense of the actions
(transition per transition) or aggregates transition sequences
into one unique new transition to make the resulting IOSTS more
abstract. It results in an IOSTS $\EuScript{S}_i$ exclusively
composed of some locations of the first IOSTS $\EuScript{S}_1$.
Consequently, for a transition or path of $\EuScript{S}_i$, we
can still retrieve the concrete path of $\EuScript{S}_1$. This
is captured by the following proposition:

\begin{proposition}
\label{prop:loc:inclu}

Let $\EuScript{S}_1$ be the first IOSTS generated from the
structured trace set $ST$. The IOSTS $\EuScript{S}_i (i>1)$
produced by Layer $i$ has a location set $L_{\EuScript{S}_i}$
such that $L_{\EuScript{S}_i} \subseteq L_{\EuScript{S}_1}$.
\end{proposition}

\textit{Completeness, soundness, complexity.} the knowledge base
is exclusively constituted by (positive) Transition facts that
have a Horn form. The rules of these layers are Modus Ponens
(soundness hypothesis). Therefore, these inference rules are
sound and complete. Furthermore, a behaviour encoded in an IOSTS
$\EuScript{S}_i$ cannot be lost in $\EuScript{S}_i$. With regards
to the (no implicit knowledge elimination) hypothesis and to
Proposition \ref{prop:loc:inclu}, the transitions of
$\EuScript{S}_i$ are either unchanged, enriched or combined
together into a new transition. The application of these layers
ends in a finite time ((finite complexity) hypothesis) and the
complexity of each is proportional to $\EuScript{O}m(k)$ with $m$
the transition number and $k$ the rule number.


\paragraph{Layer 3}
It should correspond to a set of generic rules that can be
applied on a large set of applications belonging to the same
category. This layer has two roles:

\begin{itemize}
\item the enrichment of the meaning captured in transitions. In
this step, we have chosen to mark the transitions with new
internal variables. These shall help deduce more abstract actions
in the upper layers. For example, the rules depicted in Figure
\ref{fig:rule:login} aims at recognising the receipt of a login
or logout page. The first rule means that if the response
content, which is received after a request sent with the $GET$
method,  contains a login form, then this transition is marked as
a "login page" with the assignment on the variable isLoginPage,

\begin{comment}
These rules are of the form:
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "Layer 3 rule"
when
    $t: Transition(conditions on action,Guard,
      Assign)
then
    modify ($t) (Add Assign (new assignment
    over internal variables));
end
\end{verbatim}
\end{scriptsize}
\end{comment}

\item the generic aggregation of some successive transitions.
Here, some transitions (two or more) are analysed in the
conditional part of the rule. When the rule condition is met then
the successive transitions are replaced by one transition
carrying a new action. The rule of Figure \ref{fig:rule:redirect}
corresponds to a simple transition aggregation. It aims at
recognising the successive sending of information with a POST
request followed by a redirection to another Web page.  If a
request sent with the $POST$ method has a response identified as
a redirection, (identified by the status code 301 or 302), and  a
$GET$ request comes after, both transitions are reduced into a
single one carrying the new action $PostRedirection$.

\begin{comment}
The associated rules have the form given below.
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "Simple aggregation"
when
    $t1: Transition(conditions on action, Guard,
       etc., $lfinal:=Lfinal)
    $t2: Transition(Linit == $lfinal, conditions)
then
    insert(new Transition(new Action, Guard(
       $t1.Guard, t2.Guard), Assign($t1.Assign,
       $t2.Assignment),Linit == $t1.Linit, Lfinal
       == $t2.Lfinal);
    retract($t1);
    retract($t2);
end
\end{verbatim}
\end{scriptsize}
\end{comment}

\end{itemize}

\begin{figure}[ht]
\begin{center}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "Identify Login Page"
when
    $t: Transition(Action == GET, Guard.
      response.content contains('login-form'))
then
    modify ($t) { Assign.add("isLoginPage:=true") }
end

rule "Identify Logout Request"
when
    $t: Transition(Action == GET, Guard.
      uri matches("/logout"))
then
    modify ($t1) { Assign.add("isLogout:=true") }
end

\end{verbatim}
\end{scriptsize}
\end{center}

\caption {Login and Logout page recognition rules}
\label{fig:rule:login}
\end{figure}

\begin{comment}
\begin{figure}[ht]
\begin{center}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "Identify Logout Request"
when
    $t: Transition(Action == GET, Guard.
      uri matches("/logout"))
then
    modify ($t1) { Assign.add("isLogout:=true") }
end
\end{verbatim}
\end{scriptsize}
\caption {Logout page recognition rule}
\label{fig:rule:logout}
\end{center}
\end{figure}
\end{comment}

\begin{figure}[ht]
\begin{center}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "Identify Redirection after a Post"
when
    $t1: Transition(Action == POST and
       (Guard.response.status = 301 or Guard.response.
       status = 302) and $l1final := Lfinal)
    $t2: Transition(Action == GET, linit == $l1final,
       $l2linit:=Linit)
    not (Transition (Linit == $l2linit))
then
    insert(new Transition("PostRedirection", Guard(
       $t1.Guard, $t2.Guard), Assign($t1.Assign,
       $t2.Assign), $t1.Linit, $t2.Lfinal );
    retract($t1);
    retract($t2);
end
\end{verbatim}
\end{scriptsize}

\caption {Simple aggregation} \label{fig:rule:redirect}
\end{center}
\end{figure}

\begin{example} When we apply these rules on the IOSTS example of
Figure \ref{fig:github:iosts:1}, we obtain a new IOSTS
illustrated in Figure \ref{fig:github:iosts:2}. Its size is
reduced since it has 6 transitions instead of 8 previously.
However, this new IOSTS does not clearly reflect the initial
scenario yet. Rules deducing more abstract actions are required.
These are found in the next layer.\end{example}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.6\linewidth]{figures/gh-iosts-2.png}
\caption {IOSTS $\EuScript{S}_2$} \label{fig:github:iosts:2}
\end{center}
\end{figure}

\paragraph{Layer 4}

This layer aims to infer a more abstract model composed of more
expressive actions and whose size should be reduced. Its rules
may have different forms:

\begin{itemize}
\item they can be applied on one transition only. In this case,
the rule replaces the transition action to add more sense to the
action. The rule of Figure \ref{fig:rule:deauth} is an example
which recognises a user de-authentication and adds a new action
"Deauthentication". This rule means that if a $PostRedirection$
action is triggered against a "Logout" endpoint (given by the
variable \emph{isLogout} added by Layer 3), then this is a
deauthentication,

\item the rules can also aggregate several successive transitions
up to complete paths into one transition labelled by a more
abstract action. For instance, the rule illustrated in Figure
\ref{fig:rule:auth} recognises a user authentication thanks to
the variable "isLoginPage" added by Layer 3. This rule means that
if a "Login" page is displayed, followed by a redirection
triggered by a $POST$ request, then this is an authentication
step, and the two transitions are reduced into a single one
composed of the action "Authentication".

\end{itemize}
\begin{figure}[ht]
\begin{center}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "Identify Deauthentication"
when
    $t: Transition(action == PostRedirection,
       Assign contains "isLogout:=true")
then
    modify ($t) (setAction "Deauthentication"));
end
\end{verbatim}
\end{scriptsize}
\end{center}
\caption {Deauthentication recognition rule} \label{fig:rule:deauth}
\end{figure}


\begin{figure}[ht]
\begin{center}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "Identify Authentication"
when
    $t1: Transition(Action == GET,
       Assign contains "isLoginPage:= true",
    $t1final:=Lfinal)
    $t2: Transition(Action == PostRedirection,
       Linit == $t1lfinal, $t2linit:=Linit)
    not (Transition (Linit == $t2linit))
then
    insert(new Transition("Authentication",
       Guard($t1.Guard,$t2.Guard), Assign($t1.Assign,
       $t2.Assign), $t1.Linit, $t2.Lfinal );
    retract($t1);
    retract($t2);
end
\end{verbatim}
\end{scriptsize}
\caption {Authentication recognition} \label{fig:rule:auth}
\end{center}
\end{figure}

Other rules can also be application-specific, so that these bring
specific new knowledge to the model. For instance, the GitHub Web
application has a dedicated URL grammar (a.k.a. routing system).
GitHub users own a profile page that is available at:
\emph{https://github.com/\{username\}} where \emph{\{username\}}
is the nickname of the user. However, some items are reserved
e.g., \textit{edu} and \textit{explore}. The rule given in Figure
\ref{fig:rule:gh-profile} is based upon this structure and
produces a new action "Showprofile" offering more sense.
Similarly, a GitHub page describing a project has a URL that
always matches the pattern:
\emph{https://github.com/\{username\}/\{proj}\\
\emph{ect\_name\}}. The rule of Figure \ref{fig:rule:gh-project}
captures this pattern and derives a new action named "ShowProject".

\begin{figure}[ht]
\begin{center}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "GitHub profile pages"
when
    $t: Transition(action == GET, (
       Guard.uri matches "/[a-zA-Z0-9]+$",
       Guard.uri not in [ "/edu", "/explore" ]))
then
    modify ($t) (SetAction("Showprofile"));
end
\end{verbatim}
\end{scriptsize}
\end{center}

\caption {User profile recognition} \label{fig:rule:gh-profile}
\end{figure}


\begin{figure}[ht]
\begin{center}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "GitHub project pages"
when
    $t: Transition(action == GET,
       Guard.uri matches "/[a-zA-Z0-9]+/.+$" $uri:=Guard.uri)
then
    String s=ParseProjectName($uri);
    modify ($t) (SetAction("Showproject")
      Assign.add("ProjectName:="+s) );
end
\end{verbatim}
\end{scriptsize}
\end{center}

\caption {Project choice recognition} \label{fig:rule:gh-project}
\end{figure}

\begin{example}
The application of the four previous rules leads to the final
IOSTS depicted in Figure \ref{fig:github:iosts:4}. Now, it can be
used for application comprehension since most of its actions have
a precise meaning and clearly describe the application's
behaviours.
\end{example}

\begin{figure}[ht]
    \begin{center}
    \includegraphics[width=0.6\linewidth]{figures/gh-iosts-41.png}
    \caption {IOSTS $\EuScript{S}_3$}
    \label{fig:github:iosts:4}
    \end{center}
\end{figure}

\subsection{Strategy layer}
\label{sec:modelinf:webapps:strategy}

Rather than using a static traversal strategy as in
\cite{Memon:2003,concolicandroid12,crawljax:tweb12,
Amalfitano:2012:UGR:2351676.2351717, WPX13}, we propose the
addition of an orthogonal layer in the Models generator to
describe any kind of exploration strategy by means of rules.

The simplified Algorithm of the Strategy layer is given in
Algorithm \ref{Exploration Strategy}. The latter applies the
rules on any stored IOSTS $\EuScript{S}_i$. It emerges a
location list $Loc$ that are marked with "explored" by the rules
to avoid re-using them twice (line 4). Then, the algorithm goes
back to the first generated IOSTS $\EuScript{S}_1$ in order to
extract one complete and executable path $p$ ended by a location
$l$ of $Loc$ (line 7). This step is sound since all the locations
of $\EuScript{S}_i$ belong to the location set of
$\EuScript{S}_1$ (Proposition \ref{prop:loc:inclu}). Such an
IOSTS preamble is required by the Robot explorer for trying to
reach the location $l$ by executing every action of $p$. The
algorithm finally returns a list of paths $List$, which is sent
to the Robot explorer. The exploration ends once all the
locations of $\EuScript{S}_i$ or of $\EuScript{S}_1$ are visited
(line 3). The algorithm only returns unexplored locations even
if, while the execution of the algorithm, the IOSTS
$\EuScript{S}_i$ has been regenerated several times since the
marked locations are also stored in the set $L$. Hence, if a
location of $\EuScript{S}_i$ is chosen a second time by the
rules, the algorithm checks if it has been previously visited
(line 7).

\begin{algorithm}
\SetKwInOut{Input}{input} \SetKwInOut{Output}{output}

\Input{IOSTS $\EuScript{S}_1$, $\EuScript{S}_i$}
\Output{List of preambles}

$L:=\emptyset$ List of explored locations of $\EuScript{S}_1$\;
BEGIN\;
\While{$L \neq L_{\EuScript{S}_1}$ and $L \neq \EuScript{S}_i$ }
{
1) Apply the rules on $\EuScript{S}_i$ and extract a  Location List $Loc$\;
Goback to $\EuScript{S}_1$\;

\ForEach{$l \in Loc$}{
\If{$l \notin L$}
{Compute a preamble $p$ from $l0_{\EuScript{S}_1}$ which reaches $l$\;

$L:= L \cup \{l\}$\;
$List:= List \cup  \{p\}$\;
}
%\Else{Repeat 1)}
}
}
END\;

\caption{Exploration Strategy}
 \label{Exploration Strategy}
\end{algorithm}

The rules of the Strategy layer can encode different strategies.
We propose two examples below:
\begin{itemize}

\item classical traversal strategies can still be established.
For example, Figure \ref{fig:rule:bfs} depicts two rules
expressing the choice the next location to explore in a
breadth-wise order first. First, the initial location $l0$ is
chosen and marked as explored (rule BFS).  Then, the transitions
having an initial location marked as explored and a final
location not yet explored are collected by the rule BFS2, except
for the transitions carrying an HTTP error (response status upper
or equal to 400).  These locations are marked as explored in the
IOSTS $\EuScript{S}_i$ with the method \emph{SetExplored} in the
"then" part of the rule,

\item  a semantic-driven strategy could also be applied, when the
meaning of some actions is recognisable. For instance, for
e-commerce applications, the login step and the term "buy" are
usually important. Thereby, a strategy targeting firstly the
locations of transitions carrying theses actions can be defined
by the rule\\"semantic-driven strategy" of Figure
\ref{fig:rule:semdriven}.
It is manifest that the semantic-driven strategy domain can be
tremendously vast since it depends on the number of recognised
actions and on their relevance.
\end{itemize}

\begin{figure}[ht]
\begin{center}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "BFS"
when
  $l:  Location (name == l0, explored == false)
then
    modify ($l) ( explored=true );
end

rule "BFS2"
when
    $Loc : ArrayList<Location> () from accumulate(
    $t : Transition ( Guard.response.status >199 &&
       Guard.response.status <400 && Linit.explored==
       true && Lfinal.explore==false  ),
     init( ArrayList<Transition> Loc=new ArrayList<
       Transition>(); ),
     action( Loc.add( $t.Lfinal ); ),
     result( Loc ) );
then
    Loc.SetExplored();
end
\end{verbatim}
\end{scriptsize}
\end{center}

\caption {BFS strategy} \label{fig:rule:bfs}
\end{figure}

\begin{figure}[ht]
\begin{center}
\begin{scriptsize}
\begin{verbatim}[frame=single]
rule "semantic-driven strategy"
when
    $t: Transition (Assign contains
    "isLogin:=true" || Guard.response matches "*buy*")
then
    ArrayList Loc = new ArrayList();
    Loc.add($t.Linit, $t.Lfinal );
    Loc.SetExplored();
end
\end{verbatim}
\end{scriptsize}
\end{center}

\caption {Semantic-driven strategy} \label{fig:rule:semdriven}
\end{figure}

\TODO{transition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation and experimentation}
\label{sec:modelinf:webapps:exp}

We implemented this technique in a prototype tool called
\emph{Autofunk}. A user interacts with Autofunk through a Web
interface and either gives a URL  or a file containing traces.
These have to be stored in the HTTP Archive (HAR) format as it is
the defacto standard to describe HTTP traces, used by various
HTTP related tools. Such traces can be obtained from many HTTP
monitoring tools (Mozilla Firefox or Google Chrome included).
Then, Autofunk produces IOSTS models which are stored in a
database. The last model is depicted in the Web interface. The
JBoss Drools Expert tool has been chosen to implement the
rule-based system. Such an engine leverages Object Oriented
Programming in the rule statements and takes knowledge bases
given as Java objects (Location, Transition, GET, POST objects in
this work).

The GitHub website \footnote{https://github.com/} is an example
of application giving significant results. We recorded a trace
set composed of 840 HTTP requests / responses. Then, we applied
Autofunk on them with a Models generator composed of 5 layers
gathering 18 rules whose 3 are specialised to GitHub. After
having performed trace filtering (Layer 1), we obtained a first
IOSTS tree composed of 28 transitions. The next 4 layers
automatically infer a last IOSTS tree $\EuScript{S}_4$ composed
of 12 transitions from which 9 have a clear and intelligible
meaning.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[width=.2\textwidth]{figures/gh-2-4-bis.png}
    \end{center}

    \caption {IOSTS $\EuScript{S}_4$}
    \label{fig:git:iosts}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}
\label{sec:modelinf:webapps:conclusion}

We presented an original approach combining model inference,
expert systems and automatic testing to derive IOSTSs models. Our
proposal yields several models, reflecting different levels of
abstractions of the same application with the use of inference
rules that capture the knowledge of an expert. The first
contribution lies in the flexibility and scalability brought by
the inference rules since they can be applied on several
applications or on one application only when the rules are
specific. The whole framework has not to be re-implemented for
each application. Our approach can be applied on event-driven
applications since our framework supports their exploration.
Furthermore, it can also be applied on other application types on
condition that these produce traces.
